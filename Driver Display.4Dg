#platform "uLCD-28PT"

/****************************************************************************************
*                                                                                       *
*  Driver Display                                                                       *
*                                                                                       *
****************************************************************************************/

#inherit "4DGL_16bitColours.fnc"

#inherit "VisualConst.inc"

#inherit "Driver DisplayConst.inc"

#constant BUFFER_SIZE 20

// For making something vaguely struct-like?
#constant BUF_BUF, BUF_SIZE, BUF_START, BUF_DATA_SZ

#constant BUF_STRUCT_SIZE 4


/*
 * printBuffer
 *
 * Print the data currently stored in the buffer (not the whole buffer)
 *
 * Parameters:
 * - buffer: address for a char-per-slot buffer
 * - b_size: size of the buffer
 * - b_start: the index for the start of data in the buffer
 * - data_size: the number of characters stored in the buffer
 */
func printBuffer(var buffer, var b_size, var b_start, var data_size)
    var b_end;
    b_end := (b_start + data_size) % b_size;

    if (data_size == b_size) // overflow condition
        putch(buffer[b_start]);
        b_start := (b_start + 1) % b_size;
    endif

    while (b_start != b_end)
        putch(buffer[b_start]);
        b_start := (b_start + 1) % b_size;
    wend
endfunc

func printBufferStruct(var buffer_s)
    var b_end;
    b_end := (buffer_s[BUF_START] + buffer_s[BUF_DATA_SZ]) % buffer_s[BUF_SIZE];
    var buf_ptr;
    buf_ptr := buffer_s[BUF_BUF];
    var buf_start;
    buf_start := buffer_s[BUF_START];

    if (buffer_s[BUF_DATA_SZ] == buffer_s[BUF_SIZE]) // overflow condition
        putch(buf_ptr[buf_start]);
        buf_start := (buf_start + 1) % buffer_s[BUF_SIZE];
    endif

    while (buf_start != b_end)
        putch(buf_ptr[buf_start]);
        buf_start := (buf_start + 1) % buffer_s[BUF_SIZE];
    wend
endfunc


/*
 * showBuffer
 *
 * Show the current state of the buffer
 *
 * Parameters:
 * - buffer: address for a char-per-slot buffer
 * - b_size: size of the buffer
 */
func showBuffer(var buffer, var b_size)
    var i;
    for(i:=0; i < b_size; i++)
        putch(buffer[i]);
    next
endfunc

func showBufferStruct(var buffer_s)
    var i;
    var buf_ptr;
    buf_ptr := buffer_s[BUF_BUF];
    for(i:=0; i < buffer_s[BUF_SIZE]; i++)
        putch(buf_ptr[i]);
    next
endfunc


/*
 * storeInBuffer
 *
 * Add a character to a given buffer
 *
 * Parameters:
 * - buffer: address for a char-per-slot buffer
 * - b_size: size of the buffer
 * - p_b_start: pointer to a variable holding the start of the buffer
 * - p_data_size: pointer to a variable holding the size of data in the buffer
 * - char: character to add to the buffer
 */
func storeInBuffer(var buffer, var b_size, var p_b_start, var p_data_size, var char)
    buffer[(*p_b_start + *p_data_size) % b_size] := char;

    if (*p_data_size == b_size) // overflow condition
        *p_b_start := (*p_b_start + 1) % b_size;
    else if (*p_data_size < b_size)
        (*p_data_size)++;
    endif
endfunc


func storeInBufferStruct(var buffer_s, var char)
    var buf_ptr;
    buf_ptr := buffer_s[BUF_BUF];
    buf_ptr[(buffer_s[BUF_START] + buffer_s[BUF_DATA_SZ]) % buffer_s[BUF_SIZE]] := char;

    if (buffer_s[BUF_DATA_SZ] == buffer_s[BUF_SIZE])
        buffer_s[BUF_START] := (buffer_s[BUF_START] + 1) % buffer_s[BUF_SIZE];
    else if (buffer_s[BUF_DATA_SZ] < buffer_s[BUF_SIZE])
        buffer_s[BUF_DATA_SZ]++;
    endif
endfunc


func main()
    // Form1 1.0 generated 2/9/2013 4:11:21 PM

    // Angularmeter1 1.0 generated 2/9/2013 4:11:21 PM

    gfx_Set(SCREEN_MODE,LANDSCAPE_R);

    var buffer[BUFFER_SIZE];

    var buf_struct[BUF_STRUCT_SIZE];
    buf_struct[BUF_BUF] := buffer;
    buf_struct[BUF_SIZE] := BUFFER_SIZE;
    buf_struct[BUF_START] := 0;
    buf_struct[BUF_DATA_SZ] := 0;

    var char;

    // Initialization code
    putstr("Waiting...\n");

    if (!(disk:=file_Mount()))
        while(!(disk :=file_Mount()))
            putstr("Drive not mounted...");
            pause(200);
            gfx_Cls();
            pause(200);
        wend
    endif
    gfx_TransparentColour(0x0020);
    gfx_Transparency(ON);

    hndl := file_LoadImageControl("DRIVER~1.dat", "DRIVER~1.gci", 1);
    // End initialization

    gfx_Cls();

    repeat
        char := serin(); // char < 0 when no input received.
        if (char >= 0 && char != 0x0D) // receieved non-CR character.
            gfx_Cls();

            storeInBufferStruct(buf_struct, char);

            showBufferStruct(buf_struct);
        else if (char == 0x0D) // CR: Print and reset buffer
            gfx_Cls();

            showBufferStruct(buf_struct);
            putch(0x0A); // LF
            printBufferStruct(buf_struct);

            buf_struct[BUF_START] := (buf_struct[BUF_START] + buf_struct[BUF_DATA_SZ]) % BUFFER_SIZE;
            buf_struct[BUF_DATA_SZ] := 0;
        endif
    forever

endfunc
